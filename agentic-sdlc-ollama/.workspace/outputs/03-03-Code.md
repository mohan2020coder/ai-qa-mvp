
Here are some code snippets that implement the design:

Backend (Go):
```go
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"

	_ "github.com/lib/pq" // Postgres driver
)

type Task struct {
	ID        int    `json:"id"`
	Title     string `json:"title"`
	Description string `json:"description"`
	Status   string `json:"status"`
	ReminderDate time.Time `json:"reminder_date"`
}

func main() {
	db, err := sql.Open("postgres", os.Getenv("DATABASE_URL"))
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "OK")
	})

	http.HandleFunc("/tasks", func(w http.ResponseWriter, r *http.Request) {
		var tasks []Task
		err := db.Select(&tasks, "SELECT * FROM tasks WHERE user_id = $1", 1)
		if err != nil {
			log.Fatal(err)
		}
		json.NewEncoder(w).Encode(tasks)
	})

	http.HandleFunc("/tasks/create", func(w http.ResponseWriter, r *http.Request) {
		var task Task
		err := json.NewDecoder(r.Body).Decode(&task)
		if err != nil {
			log.Fatal(err)
		}
		_, err = db.Exec("INSERT INTO tasks (title, description, status, reminder_date) VALUES ($1, $2, $3, $4)", task.Title, task.Description, task.Status, task.ReminderDate)
		if err != nil {
			log.Fatal(err)
		}
	})

	http.HandleFunc("/tasks/update", func(w http.ResponseWriter, r *http.Request) {
		var task Task
		err := json.NewDecoder(r.Body).Decode(&task)
		if err != nil {
			log.Fatal(err)
		}
		_, err = db.Exec("UPDATE tasks SET title = $1, description = $2, status = $3, reminder_date = $4 WHERE id = $5", task.Title, task.Description, task.Status, task.ReminderDate, task.ID)
		if err != nil {
			log.Fatal(err)
		}
	})

	http.HandleFunc("/tasks/delete", func(w http.ResponseWriter, r *http.Request) {
		var task Task
		err := json.NewDecoder(r.Body).Decode(&task)
		if err != nil {
			log.Fatal(err)
		}
		_, err = db.Exec("DELETE FROM tasks WHERE id = $1", task.ID)
		if err != nil {
			log.Fatal(err)
		}
	})

	http.ListenAndServe(":8080", nil)
}
```
Frontend (React):
```jsx
import React, { useState } from 'react';
import axios from 'axios';

function Tasks() {
  const [tasks, setTasks] = useState([]);

  async function fetchTasks() {
    try {
      const response = await axios.get('/tasks');
      setTasks(response.data);
    } catch (error) {
      console.log(error);
    }
  }

  return (
    <div>
      <h1>Tasks</h1>
      <ul>
        {tasks.map((task) => (
          <li key={task.id}>{task.title}</li>
        ))}
      </ul>
    </div>
  );
}
```
Dockerfile:
```dockerfile
FROM golang:1.17-alpine as builder
WORKDIR /app
COPY . .
RUN go build -o main .

FROM alpine:latest
WORKDIR /app
COPY --from=builder /app/main .
CMD ["go", "run", "main.go"]
```
CI/CD Pipeline (GitHub Actions):
```yaml
name: Deploy to Docker Hub

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Build and push Docker image
        env:
          IMAGE_NAME: my-task-management-app
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $IMAGE_NAME:$IMAGE_TAG .
          docker push $IMAGE_NAME:$IMAGE_TAG
```