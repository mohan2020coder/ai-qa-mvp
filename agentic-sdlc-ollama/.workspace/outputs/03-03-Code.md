<think>
We are going to build a simple task management web app.
 Steps:
 1. Backend in Go with endpoints for health and tasks (CRUD operations). We'll use the Gorilla Mux router for minimal routing.
 2. Frontend: Let's choose React because it is widely used and has good documentation, but we can keep it very simple.
 3. Authentication: Basic token authentication using JWT for simplicity. However, note that the requirement says "keep it minimal", so we might use a simple session or token. We'll go with JWT tokens for stateless auth.
 4. Database: Use SQLite because it's lightweight and doesn't require separate setup.

 Let's break down:

 Backend:
   - Health check endpoint: /health
   - Tasks endpoints: 
        GET /tasks -> list tasks
        POST /tasks -> create task
        PUT /tasks/{id} -> update task
        DELETE /tasks/{id} -> delete task

 We'll use the following structure for a task (for simplicity, just id, title, description, and completed):
   type Task struct {
       ID          string `json:"id"`
       Title       string `json:"title"`
       Description string `json:"description"`
       Completed   bool   `json:"completed"`
   }

 We'll use the gorilla/mux router and a JWT middleware for authentication.

 However, note: The requirement says minimal. So we might not want to overcomplicate.
 Let's consider using a simple in-memory store first? But then we need persistence. Since it's SQLite, let's set up an SQLite database and use a GORM-like ORM (but minimal). We can use the standard library for DB operations if needed.

 Alternatively, we can use a small ORM like "github.com/jinzhu/gorm" but note that the requirement is to keep it simple and minimal. Let me check: The spec says choose one between SQLite or Postgres. Since Go has good support for both with GORM, I'll go with SQLite because it's easier.

 But wait, if we are building a minimum viable product (MVP), maybe in-memory would be enough? However, the requirement includes DB and containerization, so let's use SQLite.

 We'll create:
   - A Go HTTP server that uses Mux.
   - Models for Task with GORM (SQLite).
   - JWT authentication middleware. We can generate a simple token on login and then require it for other endpoints.

 Let me outline the backend:

 1. Import necessary packages: net/http, gorilla/mux, gorm, _/github.com/mattn/go-sqlite3, etc.
 2. Define Task struct with GORM tags.
 3. Set up database connection (SQLite) and auto migrate the task model.
 4. Create a JWT middleware that checks for a valid token in the Authorization header.
 5. Implement handlers for each endpoint.

 However, note: The requirement says minimal. We might not need full ORM if we are just doing CRUD. But let's keep it simple with GORM because it will handle the database interactions and migrations easily.

 For JWT, we can use a library like "github.com/dgrijalva/jwt-go". We'll create a simple login endpoint that returns a token (with hardcoded credentials for now) and then protect the tasks endpoints.

 But wait, minimal auth: maybe just a secret key? Let's do:

   - A /login endpoint that accepts username and password. If they are correct (hardcoded), return a JWT token.
   - Then require an Authorization header with Bearer token for all task operations.

 However, note that the spec says "basic session or token". We can interpret it as having a simple way to authenticate without complex setup.

 Let's do:

   - /login: POST request with form data (username and password). If correct, return JWT token.
   - Then use this token for subsequent requests in tasks endpoints.

 But note: This is just an example. In production, you would want more secure auth.

 Now, let's write the backend code structure:

 We'll have:
   main.go
   handlers/tasks.go (or a single file with multiple functions)

 However, to keep it minimal and in one snippet if possible? The problem says "minimum viable code snippets", so we can break into multiple files but note that we are generating Go code.

 Since the requirement is for a Dockerfile and CI suggestion as well, I'll write:

   - main.go (with router setup)
   - task_model.go (if using GORM)

 But let's try to keep it in one file if possible? Or two. However, the instructions say "working, concise examples", so maybe we can do everything in one file.

 Let me structure the backend code in one file:

   package main

   import (
       // ... other imports
   )

   type Task struct {
       ID          string `gorm:"primaryKey" json:"id"`
       Title       string `json:"title"`
       Description string `json:"description"`
       Completed   bool   `json:"completed"`
   }

   var db *gorm.DB

   func main() {
       // Setup database
       // Initialize router
       r := mux.NewRouter()
       // Apply middleware to protected routes
       // Register handlers
       // Start server
   }

 But note: We are using JWT, so we need a way to generate and validate tokens.

 Let's create:

   - A secret key (hardcoded for now)
   - A function to create token (login handler will use this)
   - Middleware that checks the Authorization header

 However, let me think about the frontend. We'll have two pages: one for login and then a dashboard with tasks.

 Since we are using React, we can do:

   - Create a simple React app with two components: Login and TaskList.
   - Use fetch to call the backend endpoints.

 But note: The requirement says minimal. So let's keep the frontend very basic.

 Alternatively, if we choose Svelte, it might be even simpler? However, I'll stick with React because it has more tutorials and is widely used.

 Let me write a simple React app structure:

   - Create a new directory for frontend.
   - Use create-react-app or just set up minimal files (index.html, App.js, Login.js, TaskList.js).

 But the problem says "simple", so maybe we don't need to use create-react-app? We can have static HTML and JS.

 However, let's assume we are using React with a simple setup. I'll write:

   - index.html
   - src/App.js (with routing)
   - src/Login.js
   - src/Tasks.js

 But note: The backend must be running on the same host or CORS enabled? We can set up CORS in Go.

 Let's proceed step by step, but remember we are generating code snippets. I'll try to keep it as concise as possible.

 Since this is a text-based response and we cannot write multiple files at once, I will break down:

   Backend (Go):
     - main.go with the following:
         * Import statements
         * Task struct definition
         * Database setup (SQLite) using GORM
         * JWT secret key (hardcoded)
         * Middleware for JWT authentication
         * Handlers for tasks and health

   Frontend (React):
     - We'll create a simple React app with two components: Login and Tasks.
     - Use fetch to call the backend.

   Dockerfile:
     - Build the Go app and the React app separately, then combine them in one container? Or two containers?
     - The spec says containerize with Docker. It doesn't specify if it's one or multiple. Let me think: We can have a multi-stage build for both frontend and backend.

   CI suggestion:
     - Use GitHub Actions to build and test the Go app, and another for React tests? Or just suggest how to set up CI/CD.

 However, note that we are generating code snippets, so I'll try to write minimal working examples in each part.

 Let's start with the backend:

 We need to install:
   - Gorilla Mux: `go get -u github.com/gorilla/mux`
   - GORM for SQLite: `go get -u gorm.io/gorm` and `go get -u gorm.io/driver/sqlite`

 But note: The requirement is minimal, so maybe we don't need a full ORM? We can use the standard library. However, let's stick with GORM because it simplifies CRUD.

 Alternatively, if we are doing minimal, we might not even use an ORM and just do raw SQL. Let me adjust:

   - Use the standard library for DB operations to keep it more Go-native and less dependencies.

 But then again, GORM is popular and easy. However, let's consider that the requirement says "minimal", so maybe avoid extra libraries? We can write simple CRUD functions with sql.DB.

 I'll choose raw SQL because we are keeping minimal and also SQLite driver for Go is standard (github.com/mattn/go-sqlite3). But note: GORM might be easier for migrations, but let's do without ORM to keep it minimal.

 Let me change the plan:

   Backend:
     - Use `database/sql` and `github.com/mattn/go-sqlite3`
     - Define a Task struct.
     - Write functions to handle CRUD operations (using prepared statements).

   Steps in Go backend:

     1. Import necessary packages.
     2. Open SQLite database.
     3. Create table if not exists.
     4. Implement handlers for tasks and health.

 Let's write the main.go file accordingly.

 However, note: We are using JWT authentication. So we need to handle tokens.

 I'll create:

   - A /login endpoint that returns a token (if credentials are correct).
   - Then use this token in subsequent requests by including it in the Authorization