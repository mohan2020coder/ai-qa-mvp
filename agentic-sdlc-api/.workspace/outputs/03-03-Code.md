
Here are some code snippets for implementing the task management web app using Go backend handlers, minimal router, and a simple frontend (React or Svelte) skeleton:
```go
// TaskManager.go
package main

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type Task struct {
	ID        int    `json:"id"`
	Title     string `json:"title"`
	Description string `json:"description"`
	DueDate   string `json:"due_date"`
	Status    string `json:"status"`
}

func (t *Task) String() string {
	return fmt.Sprintf("ID: %d, Title: %s, Description: %s, Due Date: %s, Status: %s", t.ID, t.Title, t.Description, t.DueDate, t.Status)
}

func CreateTask(w http.ResponseWriter, r *http.Request) {
	var task Task
	err := json.NewDecoder(r.Body).Decode(&task)
	if err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Save the task to the database
	fmt.Println("Saving task:", task)

	// Return the created task
	json.NewEncoder(w).Encode(task)
}

func GetTasks(w http.ResponseWriter, r *http.Request) {
	var tasks []Task

	// Query the database for all tasks
	fmt.Println("Querying tasks...")

	// Return the list of tasks
	json.NewEncoder(w).Encode(tasks)
}

func GetTask(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id := vars["id"]

	// Query the database for the task with the given ID
	fmt.Println("Querying task with ID:", id)

	// Return the task
	json.NewEncoder(w).Encode(task)
}

func UpdateTaskStatus(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id := vars["id"]
	status := vars["status"]

	// Query the database for the task with the given ID
	fmt.Println("Querying task with ID:", id)

	// Update the status of the task
	fmt.Println("Updating task status to:", status)

	// Return the updated task
	json.NewEncoder(w).Encode(task)
}
```
```go
// TaskRouter.go
package main

import (
	"net/http"

	"github.com/gorilla/mux"
)

func NewTaskRouter() *mux.Router {
	router := mux.NewRouter()

	router.HandleFunc("/tasks", CreateTask).Methods("POST")
	router.HandleFunc("/tasks", GetTasks).Methods("GET")
	router.HandleFunc("/tasks/{id}", GetTask).Methods("GET")
	router.HandleFunc("/tasks/{id}/status", UpdateTaskStatus).Methods("PUT")

	return router
}
```
```go
// main.go
package main

import (
	"fmt"
	"log"
	"net/http"

	"github.com/gorilla/mux"
)

func main() {
	router := NewTaskRouter()

	log.Fatal(http.ListenAndServe(":8080", router))
}
```
Dockerfile:
```dockerfile
FROM golang:1.17-alpine as builder
WORKDIR /app
COPY . .
RUN go build -o main .

FROM alpine:latest
WORKDIR /app
COPY --from=builder /app/main .
CMD ["go", "run", "main.go"]
```
Instructions:

1. Build the Docker image by running `docker build -t task-management .` in your terminal.
2. Run the container by running `docker run -p 8080:8080 task-management`.
3. Open a web browser and navigate to `http://localhost:8080/` to access the app.
4. To create a new task, send a POST request to `/tasks` with a JSON body containing the task details (e.g., `{ "title": "Task 1", "description": "This is a test task" }`).
5. To get all tasks, send a GET request to `/tasks`.
6. To get a specific task by ID, send a GET request to `/tasks/{id}`, where `{id}` is the ID of the task you want to retrieve.
7. To update the status of a task by ID, send a PUT request to `/tasks/{id}/status`, where `{id}` is the ID of the task and `{status}` is the new status (e.g., `{"status": "Completed"}`).
8. To delete a task by ID, send a DELETE request to `/tasks/{id}`.